"""Vulnerability scanning endpoints using DeepTeam."""

from typing import List, Optional, Dict, Any
from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel, Field
import logging

from app.services.deepteam_service import deepteam_service
from app.core.dependencies import get_current_user_optional

logger = logging.getLogger(__name__)

router = APIRouter(
    tags=["vulnerability-scanner"],
    responses={404: {"description": "Not found"}},
)


class EndpointTarget(BaseModel):
    """Target endpoint to scan for vulnerabilities."""
    url: str = Field(..., description="The URL of the endpoint to scan")
    name: str = Field(..., description="Name/identifier for the endpoint")
    type: str = Field(default="model", description="Type of endpoint (model, guardrail, agent, etc)")
    headers: Optional[Dict[str, str]] = Field(default=None, description="Optional headers for authentication")
    vulnerabilities: Optional[List[str]] = Field(default=None, description="Override vulnerabilities for this target")
    attack_methods: Optional[List[str]] = Field(default=None, description="Override attack methods for this target")
    max_rounds: Optional[int] = Field(default=None, description="Override max rounds for this target")


class ScanRequest(BaseModel):
    """Request for scanning endpoints for vulnerabilities."""
    targets: List[EndpointTarget] = Field(..., description="List of endpoints to scan")
    vulnerabilities: Optional[List[str]] = Field(
        default=None,
        description="Vulnerability types to test: BIAS, PII_LEAKAGE, TOXICITY, PROMPT_LEAKAGE, ILLEGAL_ACTIVITY, MISINFORMATION"
    )
    attack_methods: Optional[List[str]] = Field(
        default=None,
        description="Attack methods to use (default: red_teaming)"
    )
    max_rounds: int = Field(
        default=5,
        description="Maximum rounds of testing per vulnerability",
        ge=1,
        le=20
    )


class ScanResult(BaseModel):
    """Result from a vulnerability scan."""
    target_name: str
    target_url: str
    target_type: str
    vulnerabilities_tested: List[str]
    findings: List[Dict[str, Any]]
    summary: Dict[str, int]
    status: str
    error: Optional[str] = None


class ScanResponse(BaseModel):
    """Response from vulnerability scanning."""
    scan_id: str
    targets_scanned: int
    results: List[ScanResult]


@router.get("/health")
async def health_check():
    """Check vulnerability scanner service health."""
    return {
        "status": "healthy",
        "service": "vulnerability-scanner",
        "deepteam_available": deepteam_service.api_key is not None,
        "message": "Scanner ready" if deepteam_service.api_key else "OpenAI API key required"
    }


@router.post("/scan", response_model=ScanResponse)
async def scan_endpoints(
    request: ScanRequest,
    current_user=Depends(get_current_user_optional)
):
    """
    Scan endpoints for vulnerabilities using DeepTeam.

    This endpoint can test any provided endpoint (agents, models, guardrails)
    against various vulnerability types including:
    - BIAS: Tests for various types of bias in responses
    - PII_LEAKAGE: Tests for personal information exposure
    - TOXICITY: Tests for harmful or toxic content
    - PROMPT_LEAKAGE: Tests for system prompt exposure
    - ILLEGAL_ACTIVITY: Tests for illegal content generation
    - MISINFORMATION: Tests for false information generation

    The scanner will send crafted prompts to the target endpoints and
    evaluate their responses for vulnerabilities.
    """
    # Check if API key is available
    if not deepteam_service.api_key:
        raise HTTPException(
            status_code=503,
            detail="OpenAI API key is required for vulnerability scanning. Please set OPENAI_API_KEY environment variable."
        )

    results = []
    scan_id = f"scan_{hash(str(request.targets))}"

    for target in request.targets:
        try:
            logger.info(f"Starting vulnerability scan for {target.name} at {target.url}")

            # Scan the endpoint - use target-specific overrides if provided
            scan_result = await deepteam_service.scan_endpoint(
                endpoint_url=target.url,
                vulnerabilities=target.vulnerabilities or request.vulnerabilities,
                attack_methods=target.attack_methods or request.attack_methods,
                headers=target.headers,
                max_rounds=target.max_rounds or request.max_rounds
            )

            # Create structured result
            result = ScanResult(
                target_name=target.name,
                target_url=target.url,
                target_type=target.type,
                vulnerabilities_tested=scan_result.get("vulnerabilities_tested", []),
                findings=scan_result.get("findings", []),
                summary=scan_result.get("summary", {
                    "total_tests": 0,
                    "vulnerabilities_found": 0,
                    "critical_findings": 0,
                    "high_findings": 0,
                    "medium_findings": 0,
                    "low_findings": 0
                }),
                status="completed",
                error=scan_result.get("error")
            )

            results.append(result)
            logger.info(f"Completed scan for {target.name}: {result.summary['vulnerabilities_found']} vulnerabilities found")

        except Exception as e:
            logger.error(f"Error scanning {target.name} at {target.url}: {e}")
            results.append(ScanResult(
                target_name=target.name,
                target_url=target.url,
                target_type=target.type,
                vulnerabilities_tested=request.vulnerabilities or [],
                findings=[],
                summary={
                    "total_tests": 0,
                    "vulnerabilities_found": 0,
                    "critical_findings": 0,
                    "high_findings": 0,
                    "medium_findings": 0,
                    "low_findings": 0
                },
                status="failed",
                error=str(e)
            ))

    return ScanResponse(
        scan_id=scan_id,
        targets_scanned=len(request.targets),
        results=results
    )


@router.get("/scan/{scan_id}")
async def get_scan_result(scan_id: str):
    """
    Get results of a previous scan (placeholder for future implementation).

    Note: Currently scans are not persisted. This endpoint is a placeholder
    for future implementation where scan results could be stored and retrieved.
    """
    raise HTTPException(
        status_code=501,
        detail="Scan history not yet implemented. Scans are currently ephemeral."
    )