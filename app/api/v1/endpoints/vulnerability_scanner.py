"""Vulnerability scanning endpoints using DeepTeam with async Celery support."""

from typing import List, Optional, Dict, Any
from uuid import uuid4
from datetime import datetime
from fastapi import APIRouter, HTTPException, Depends, Query
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from pydantic import BaseModel, Field
import logging

from app.services.deepteam_service import deepteam_service
from app.core.dependencies import get_current_user_optional, get_db
from app.models.vulnerability_scan import VulnerabilityScan, VulnerabilityScanStatus
from app.workers.tasks.vulnerability_scan_tasks import run_vulnerability_scan_task

logger = logging.getLogger(__name__)

router = APIRouter(
    tags=["vulnerability-scanner"],
    responses={404: {"description": "Not found"}},
)


class EndpointTarget(BaseModel):
    """Target endpoint to scan for vulnerabilities."""
    url: str = Field(..., description="The URL of the endpoint to scan")
    name: str = Field(..., description="Name/identifier for the endpoint")
    type: str = Field(default="model", description="Type of endpoint (model, guardrail, agent, etc)")
    headers: Optional[Dict[str, str]] = Field(default=None, description="Optional headers for authentication")
    vulnerabilities: Optional[List[str]] = Field(default=None, description="Override vulnerabilities for this target")
    attack_methods: Optional[List[str]] = Field(default=None, description="Override attack methods for this target")
    max_rounds: Optional[int] = Field(default=None, description="Override max rounds for this target")


class ScanRequest(BaseModel):
    """Request for scanning endpoints for vulnerabilities."""
    name: str = Field(..., description="Name for this scan")
    description: Optional[str] = Field(None, description="Description of the scan")
    targets: List[EndpointTarget] = Field(..., description="List of endpoints to scan")
    vulnerabilities: Optional[List[str]] = Field(
        default=None,
        description="Vulnerability types to test: BIAS, PII_LEAKAGE, TOXICITY, PROMPT_LEAKAGE, ILLEGAL_ACTIVITY, MISINFORMATION"
    )
    attack_methods: Optional[List[str]] = Field(
        default=None,
        description="Attack methods to use (default: red_teaming)"
    )
    max_rounds: int = Field(
        default=5,
        description="Maximum rounds of testing per vulnerability",
        ge=1,
        le=20
    )


class ScanResult(BaseModel):
    """Result from a vulnerability scan."""
    target_name: str
    target_url: str
    target_type: str
    vulnerabilities_tested: List[str]
    findings: List[Dict[str, Any]]
    summary: Dict[str, int]
    status: str
    error: Optional[str] = None


class AsyncScanResponse(BaseModel):
    """Response from async vulnerability scanning."""
    scan_id: str
    name: str
    status: str
    message: str


class ScanStatusResponse(BaseModel):
    """Response for scan status check."""
    scan_id: str
    name: str
    status: str
    progress: Optional[float] = None
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    results: Optional[Dict[str, Any]] = None


class ScanListItem(BaseModel):
    """Item in scan list response."""
    id: str
    name: str
    description: Optional[str]
    status: str
    created_at: datetime
    started_at: Optional[datetime]
    completed_at: Optional[datetime]


@router.get("/health")
async def health_check():
    """Check vulnerability scanner service health."""
    return {
        "status": "healthy",
        "service": "vulnerability-scanner",
        "deepteam_available": deepteam_service.api_key is not None,
        "message": "Scanner ready" if deepteam_service.api_key else "OpenAI API key required"
    }


@router.post("/scan", response_model=AsyncScanResponse)
async def scan_endpoints(
    request: ScanRequest,
    db: AsyncSession = Depends(get_db),
    current_user=Depends(get_current_user_optional)
):
    """
    Start an async vulnerability scan using Celery.

    This endpoint creates a scan record and queues it for background processing.
    Use GET /scan/{scan_id} to check status and retrieve results.
    """
    try:
        # Create scan record in database
        scan = VulnerabilityScan(
            name=request.name,
            description=request.description,
            target_config={
                "targets": [target.dict() for target in request.targets],
                "vulnerabilities": request.vulnerabilities or [
                    "BIAS", "PII_LEAKAGE", "TOXICITY",
                    "PROMPT_LEAKAGE", "ILLEGAL_ACTIVITY", "MISINFORMATION"
                ],
                "attack_methods": request.attack_methods or ["red_teaming"],
                "max_rounds": request.max_rounds
            },
            status=VulnerabilityScanStatus.PENDING,
            created_by=current_user.email if current_user else "anonymous"
        )

        db.add(scan)
        await db.commit()
        await db.refresh(scan)

        # Queue Celery task
        task = run_vulnerability_scan_task.apply_async(
            args=[str(scan.id), scan.name],
            queue="vulnerability_scans"
        )

        logger.info(f"Queued vulnerability scan {scan.id} with task ID {task.id}")

        return AsyncScanResponse(
            scan_id=str(scan.id),
            name=scan.name,
            status="pending",
            message=f"Scan queued for processing. Check status at /scan/{scan.id}"
        )

    except Exception as e:
        logger.error(f"Error creating scan: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to create scan: {str(e)}"
        )


@router.get("/scans/{scan_id}", response_model=ScanStatusResponse)
async def get_scan_details(
    scan_id: str,
    db: AsyncSession = Depends(get_db),
    current_user=Depends(get_current_user_optional)
):
    """Get details and results of a vulnerability scan."""
    try:
        result = await db.execute(
            select(VulnerabilityScan).where(VulnerabilityScan.id == scan_id)
        )
        scan = result.scalar_one_or_none()

        if not scan:
            raise HTTPException(
                status_code=404,
                detail=f"Scan {scan_id} not found"
            )

        return ScanStatusResponse(
            scan_id=str(scan.id),
            name=scan.name,
            status=scan.status.value,
            progress=scan.progress,
            started_at=scan.started_at,
            completed_at=scan.completed_at,
            results=scan.results if scan.status == VulnerabilityScanStatus.COMPLETED else None
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error fetching scan {scan_id}: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to fetch scan: {str(e)}"
        )


@router.get("/scans/{scan_id}/status")
async def get_scan_status(
    scan_id: str,
    db: AsyncSession = Depends(get_db),
    current_user=Depends(get_current_user_optional)
):
    """Get just the status of a vulnerability scan (lightweight endpoint for polling)."""
    try:
        result = await db.execute(
            select(VulnerabilityScan.status, VulnerabilityScan.progress)
            .where(VulnerabilityScan.id == scan_id)
        )
        scan_data = result.first()

        if not scan_data:
            raise HTTPException(
                status_code=404,
                detail=f"Scan {scan_id} not found"
            )

        return {
            "scan_id": scan_id,
            "status": scan_data.status.value,
            "progress": scan_data.progress
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error fetching scan status {scan_id}: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to fetch scan status: {str(e)}"
        )


@router.get("/scans", response_model=List[ScanListItem])
async def list_scans(
    limit: int = Query(10, ge=1, le=100),
    offset: int = Query(0, ge=0),
    status: Optional[str] = Query(None, description="Filter by status"),
    db: AsyncSession = Depends(get_db),
    current_user=Depends(get_current_user_optional)
):
    """List all vulnerability scans with pagination."""
    try:
        query = select(VulnerabilityScan).order_by(VulnerabilityScan.created_at.desc())

        if status:
            try:
                status_enum = VulnerabilityScanStatus(status)
                query = query.where(VulnerabilityScan.status == status_enum)
            except ValueError:
                raise HTTPException(
                    status_code=400,
                    detail=f"Invalid status: {status}. Valid values are: {[s.value for s in VulnerabilityScanStatus]}"
                )

        query = query.limit(limit).offset(offset)

        result = await db.execute(query)
        scans = result.scalars().all()

        return [
            ScanListItem(
                id=str(scan.id),
                name=scan.name,
                description=scan.description,
                status=scan.status.value,
                created_at=scan.created_at,
                started_at=scan.started_at,
                completed_at=scan.completed_at
            )
            for scan in scans
        ]

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error listing scans: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to list scans: {str(e)}"
        )


@router.delete("/scans/{scan_id}")
async def delete_scan(
    scan_id: str,
    db: AsyncSession = Depends(get_db),
    current_user=Depends(get_current_user_optional)
):
    """Delete a vulnerability scan and its results."""
    try:
        # First check if the scan exists
        result = await db.execute(
            select(VulnerabilityScan).where(VulnerabilityScan.id == scan_id)
        )
        scan = result.scalar_one_or_none()

        if not scan:
            raise HTTPException(
                status_code=404,
                detail=f"Scan {scan_id} not found"
            )

        # Check if scan is currently running
        if scan.status == VulnerabilityScanStatus.RUNNING:
            raise HTTPException(
                status_code=400,
                detail="Cannot delete a scan that is currently running. Please wait for it to complete or fail."
            )

        # Delete the scan
        await db.delete(scan)
        await db.commit()

        logger.info(f"Deleted vulnerability scan {scan_id}")

        return {
            "success": True,
            "message": f"Scan {scan_id} deleted successfully"
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error deleting scan {scan_id}: {e}")
        await db.rollback()
        raise HTTPException(
            status_code=500,
            detail=f"Failed to delete scan: {str(e)}"
        )