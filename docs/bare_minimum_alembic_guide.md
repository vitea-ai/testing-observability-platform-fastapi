# The Bare Minimum Alembic Guide

A practical guide to database migrations with Alembic - what to do, what to avoid, and how to save yourself from migration hell.

## What is Alembic?

Alembic is SQLAlchemy's database migration tool. Think of it as version control for your database schema - tracking every change, allowing rollbacks, and keeping all environments in sync.

## Why You Need Migrations

### Without Migrations (The Painful Way)
```python
# Developer 1: "I'll just add a column"
ALTER TABLE users ADD COLUMN age INTEGER;

# Developer 2: "Did Dev1 run their SQL? What columns exist?"
# Production: "Why is the app crashing?"
# New Developer: "How do I set up the database?"
```

### With Alembic (The Right Way)
```bash
# Everyone runs:
alembic upgrade head
# Database is now in correct state, every time
```

## Essential Commands

### 1. Initial Setup
```bash
# Initialize Alembic in your project
alembic init alembic

# Creates:
# alembic/
#   ‚îú‚îÄ‚îÄ versions/       # Your migration files
#   ‚îú‚îÄ‚îÄ script.py.mako  # Template for new migrations
#   ‚îî‚îÄ‚îÄ env.py          # Configuration
# alembic.ini           # Main config file
```

### 2. Creating Migrations

```bash
# Auto-generate migration from model changes
alembic revision --autogenerate -m "add user age column"

# Create empty migration for custom SQL
alembic revision -m "create custom index"
```

### 3. Running Migrations

```bash
# Upgrade to latest
alembic upgrade head

# Upgrade step by step
alembic upgrade +1

# Downgrade one revision
alembic downgrade -1

# Reset to beginning
alembic downgrade base
```

### 4. Checking Status

```bash
# Current revision
alembic current

# History of migrations
alembic history

# Show SQL without running
alembic upgrade head --sql
```

## Best Practices

### 1. ‚úÖ Always Review Auto-Generated Migrations

**Why**: Autogenerate isn't perfect. It can miss things or generate dangerous operations.

```python
# ALWAYS check the generated migration
def upgrade():
    # Autogenerated might create:
    op.drop_table('important_table')  # üò± Was this intentional?
    
    # Review and fix:
    # op.drop_table('old_unused_table')  # ‚úÖ Correct table
```

### 2. ‚úÖ Make Migrations Reversible

**Why**: You WILL need to rollback someday.

```python
# GOOD - Fully reversible
def upgrade():
    op.add_column('users', sa.Column('age', sa.Integer))

def downgrade():
    op.drop_column('users', 'age')

# BAD - Can't undo data deletion
def upgrade():
    op.execute("DELETE FROM users WHERE active = false")
    
def downgrade():
    pass  # üíÄ Data is gone forever
```

### 3. ‚úÖ Use Batch Operations for SQLite

**Why**: SQLite doesn't support most ALTER TABLE operations.

```python
# GOOD - Works with SQLite
with op.batch_alter_table('users') as batch_op:
    batch_op.add_column(sa.Column('age', sa.Integer))
    batch_op.create_index('ix_users_age', ['age'])

# BAD - Fails on SQLite
op.add_column('users', sa.Column('age', sa.Integer))
```

### 4. ‚úÖ Handle Data Migrations Separately

**Why**: Schema and data migrations have different concerns.

```python
# GOOD - Separate concerns
# Migration 001_add_status_column.py
def upgrade():
    op.add_column('orders', sa.Column('status', sa.String(50)))

# Migration 002_populate_status.py
def upgrade():
    connection = op.get_bind()
    connection.execute(
        "UPDATE orders SET status = 'pending' WHERE status IS NULL"
    )

# Migration 003_make_status_required.py
def upgrade():
    op.alter_column('orders', 'status', nullable=False)
```

### 5. ‚úÖ Test Migrations Both Ways

```bash
# Always test upgrade AND downgrade
alembic upgrade head
alembic downgrade -1
alembic upgrade head
```

### 6. ‚úÖ Use Naming Conventions

```python
# In your models.py or database config
naming_convention = {
    "ix": "ix_%(column_0_label)s",
    "uq": "uq_%(table_name)s_%(column_0_name)s",
    "ck": "ck_%(table_name)s_%(constraint_name)s",
    "fk": "fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s",
    "pk": "pk_%(table_name)s"
}

metadata = MetaData(naming_convention=naming_convention)
```

### 7. ‚úÖ Add Docstrings to Complex Migrations

```python
def upgrade():
    """
    Splits the 'name' column into 'first_name' and 'last_name'.
    
    Note: This assumes names are in "First Last" format.
    Names with middle names will put everything after first space in last_name.
    """
    op.add_column('users', sa.Column('first_name', sa.String(100)))
    op.add_column('users', sa.Column('last_name', sa.String(100)))
    
    # Populate new columns from existing data
    op.execute("""
        UPDATE users 
        SET first_name = SPLIT_PART(name, ' ', 1),
            last_name = SPLIT_PART(name, ' ', 2)
    """)
```

## What NOT to Do (Common Pitfalls)

### 1. ‚ùå Never Edit Migrations After Running

```python
# If you've run this migration:
def upgrade():
    op.add_column('users', sa.Column('age', sa.Integer))

# DON'T edit it to:
def upgrade():
    op.add_column('users', sa.Column('age', sa.Integer, nullable=False))
    
# Instead, create a NEW migration:
def upgrade():
    op.alter_column('users', 'age', nullable=False)
```

### 2. ‚ùå Don't Use DROP Cascade in Production

```python
# DANGEROUS
def upgrade():
    op.execute("DROP TABLE users CASCADE")  # üíÄ Deletes related data!

# SAFER
def upgrade():
    # First handle relationships
    op.drop_constraint('fk_orders_user_id', 'orders')
    # Then drop table
    op.drop_table('users')
```

### 3. ‚ùå Don't Ignore Failed Migrations

```bash
# If migration fails, DON'T:
alembic stamp head  # üö´ Pretending it worked

# DO: Fix the issue, then:
alembic current  # Check actual state
alembic upgrade head  # Try again
```

### 4. ‚ùå Don't Mix Schema Providers

```python
# BAD - Mixing Alembic with manual changes
cursor.execute("ALTER TABLE users ADD COLUMN age INTEGER")  # Manual
alembic upgrade head  # Now Alembic is confused

# GOOD - Everything through Alembic
alembic revision -m "add age to users"
# Edit migration file
alembic upgrade head
```

### 5. ‚ùå Don't Forget About Indexes

```python
# BAD - Adding column without considering performance
def upgrade():
    op.add_column('orders', sa.Column('user_id', sa.Integer))
    # Missing: op.create_index('ix_orders_user_id', 'orders', ['user_id'])

# GOOD - Think about query patterns
def upgrade():
    op.add_column('orders', sa.Column('user_id', sa.Integer))
    op.create_index('ix_orders_user_id', 'orders', ['user_id'])
```

### 6. ‚ùå Don't Use Auto-Generate Blindly

```python
# Autogenerate MISSES:
# - Custom SQL functions
# - Triggers
# - Views
# - Some constraint changes
# - Data type changes (sometimes)

# Always review and add missing pieces manually
```

## Advanced Patterns

### 1. Async Migrations with FastAPI

```python
# alembic/env.py
import asyncio
from sqlalchemy.ext.asyncio import async_engine_from_config

def run_async_migrations():
    async def run_migrations():
        async with connectable.connect() as connection:
            await connection.run_sync(do_run_migrations)
    
    asyncio.run(run_migrations())

# For async SQLAlchemy
```

### 2. Multi-Tenant Migrations

```python
def upgrade():
    # Get all tenant schemas
    connection = op.get_bind()
    schemas = connection.execute("SELECT schema_name FROM tenants").fetchall()
    
    for schema, in schemas:
        # Run migration for each tenant
        op.execute(f"SET search_path TO {schema}")
        op.add_column('users', sa.Column('age', sa.Integer))
```

### 3. Zero-Downtime Migrations

```python
# Step 1: Add column (nullable)
def upgrade():
    op.add_column('users', sa.Column('email_verified', sa.Boolean))

# Deploy new code that writes to both old and new

# Step 2: Backfill data
def upgrade():
    op.execute("""
        UPDATE users 
        SET email_verified = true 
        WHERE confirmed_at IS NOT NULL
    """)

# Step 3: Make required and remove old column
def upgrade():
    op.alter_column('users', 'email_verified', nullable=False)
    op.drop_column('users', 'confirmed_at')
```

### 4. Migration Rollback Strategy

```python
# Tag production revision before deploying
alembic history  # Note current revision
git tag db-v1.2.3 <revision>

# If rollback needed:
alembic downgrade <tagged-revision>
```

## Configuration Best Practices

### 1. Environment-Specific Configs

```python
# alembic/env.py
import os
from dotenv import load_dotenv

load_dotenv()

config.set_main_option("sqlalchemy.url", os.getenv("DATABASE_URL"))
```

### 2. Exclude Tables from Autogenerate

```python
# alembic/env.py
def include_object(object, name, type_, reflected, compare_to):
    # Skip audit tables
    if type_ == "table" and name.startswith("audit_"):
        return False
    return True

context.configure(
    include_object=include_object,
    # ...
)
```

### 3. Custom Migration Template

```mako
# alembic/script.py.mako
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

# TODO: Review this migration!
# [ ] Tested upgrade locally
# [ ] Tested downgrade locally
# [ ] Reviewed for data loss
# [ ] Added indexes where needed
"""
```

## Testing Migrations

### 1. Unit Test Your Migrations

```python
import pytest
from alembic import command
from alembic.config import Config

def test_migration_upgrade_downgrade():
    alembic_cfg = Config("alembic.ini")
    
    # Upgrade to head
    command.upgrade(alembic_cfg, "head")
    
    # Verify schema
    # ... check tables exist ...
    
    # Downgrade
    command.downgrade(alembic_cfg, "-1")
    
    # Verify rollback
    # ... check changes reverted ...
```

### 2. CI/CD Pipeline

```yaml
# GitHub Actions
- name: Check migrations
  run: |
    alembic upgrade head
    alembic check  # Requires alembic-verify package
```

## Common Scenarios

### Adding a NOT NULL Column

```python
# Step 1: Add nullable column
def upgrade():
    op.add_column('users', sa.Column('account_type', sa.String(50)))

# Step 2: Populate with default
def upgrade():
    op.execute("UPDATE users SET account_type = 'standard' WHERE account_type IS NULL")

# Step 3: Make NOT NULL
def upgrade():
    op.alter_column('users', 'account_type', nullable=False)
```

### Renaming a Column

```python
def upgrade():
    op.alter_column('users', 'email_address', new_column_name='email')

def downgrade():
    op.alter_column('users', 'email', new_column_name='email_address')
```

### Creating a Partial Index

```python
def upgrade():
    op.create_index(
        'ix_active_users_email',
        'users',
        ['email'],
        postgresql_where='active = true'  # Partial index
    )
```

## Emergency Procedures

### When Things Go Wrong

```bash
# 1. Check current state
alembic current

# 2. Check history
alembic history

# 3. If migration partially applied, manually fix:
# - Complete the remaining operations
# - Or reverse what was done

# 4. Mark database state
alembic stamp <revision>  # Tell Alembic where we actually are

# 5. Continue normally
alembic upgrade head
```

### Nuclear Option: Rebuild

```bash
# When all else fails (DEVELOPMENT ONLY!)
drop database myapp;
create database myapp;
alembic upgrade head
```

## Summary: Golden Rules

1. **Always review autogenerated migrations**
2. **Test both upgrade and downgrade**
3. **Never edit already-run migrations**
4. **Keep migrations small and focused**
5. **Separate schema changes from data changes**
6. **Use batch operations for SQLite**
7. **Add indexes for foreign keys**
8. **Document complex migrations**
9. **Handle nullable columns in steps**
10. **Have a rollback plan**

Remember: Migrations are code. Review them, test them, and treat them with respect. Your future self will thank you!